<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/assets/css/styles.css">
    <link rel="shortcut icon" type="image/png" href="/assets/favicon.png" type="image/x-icon">
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Making a Good P.O.C. | Harry Ganz</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Making a Good P.O.C." />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Doing a proof-of-concept (P.O.C.) before building something complex or uncertain is an immensely useful tool when developing software; however, I learned that it is pretty easy to mess up a P.O.C. and turn it from something useful into a total waste of time. If a P.O.C. is done right it can help identify tricky parts of an approach and nail down feasibility. If a P.O.C. is done wrong, it could fail to actually assess how feasible an approach is and lead to poor estimates, missed deadlines, and possibly even an unusable mess of software." />
<meta property="og:description" content="Doing a proof-of-concept (P.O.C.) before building something complex or uncertain is an immensely useful tool when developing software; however, I learned that it is pretty easy to mess up a P.O.C. and turn it from something useful into a total waste of time. If a P.O.C. is done right it can help identify tricky parts of an approach and nail down feasibility. If a P.O.C. is done wrong, it could fail to actually assess how feasible an approach is and lead to poor estimates, missed deadlines, and possibly even an unusable mess of software." />
<link rel="canonical" href="http://localhost:4000/2024/03/07/making-a-good-poc.html" />
<meta property="og:url" content="http://localhost:4000/2024/03/07/making-a-good-poc.html" />
<meta property="og:site_name" content="Harry Ganz" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-03-07T00:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Making a Good P.O.C." />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-03-07T00:00:00-05:00","datePublished":"2024-03-07T00:00:00-05:00","description":"Doing a proof-of-concept (P.O.C.) before building something complex or uncertain is an immensely useful tool when developing software; however, I learned that it is pretty easy to mess up a P.O.C. and turn it from something useful into a total waste of time. If a P.O.C. is done right it can help identify tricky parts of an approach and nail down feasibility. If a P.O.C. is done wrong, it could fail to actually assess how feasible an approach is and lead to poor estimates, missed deadlines, and possibly even an unusable mess of software.","headline":"Making a Good P.O.C.","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2024/03/07/making-a-good-poc.html"},"url":"http://localhost:4000/2024/03/07/making-a-good-poc.html"}</script>
<!-- End Jekyll SEO tag -->

</head><body>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9F8FH9LMMH"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9F8FH9LMMH');
</script>
<header>
    <div class="flex flex-col-md-row">
        <img class="site-logo" alt="Bear Logo" src="/assets/img/bear_logo.png" height="64px" width="64px" />
        <a class="site-title flex-item" rel="author" href="/"><h1>Harry Ganz</h1></a>
        
        <nav class="site-nav flex-right">
            <div class="flex flex-col-md-row m-b-0-sm-1">

            
                
                
            
                
                
                    <a class="page-link flex-item" href="/about/">About</a>
                
            
                
                
            
                
                
                    <a class="page-link flex-item" href="/">Home</a>
                
            
                
                
            
                
                
            
        </nav>
        
    </div>
</header><main aria-label="Content">
      <div class="flex flex-column">
        <article class="post">
    
        <h2 class="post-title">Making a Good P.O.C.</h2>
    

    <div class="post-content"><p>Doing a proof-of-concept (P.O.C.) before building something complex or uncertain is an immensely useful 
tool when developing software; however, I learned that it is pretty easy to mess up a P.O.C. and turn
it from something useful into a total waste of time. If a P.O.C. is done right it can help identify
tricky parts of an approach and nail down feasibility. If a P.O.C. is done wrong, it could fail to
actually assess how feasible an approach is and lead to poor estimates, missed deadlines, and
possibly even an unusable mess of software.</p>

<h3 id="introduction">Introduction</h3>

<p>I am a huge fan of proofs of concept. Many software problems are “wicked” in that you cannot
assess how difficult they are going to be until you start solving them. Edge cases, backtracking,
hidden complexity, and unknowns pop up all over the place and it is impossible before you set out to
tell how long and winding the road really is. For that reason, a quick, targeted attempt at a partial solution
is often a good way of figuring out what the hard parts will be, and whether your approach will actually work. A good P.O.C.
can save time by preventing a team from going down “blind alleys” and, because you already have some idea of how hard the 
problem is to solve, will also improve time estimates for the final solution. A bad P.O.C. is simply a waste of time.</p>

<p>Before explaining how to make a good P.O.C. it is probably worth defining a few terms.</p>

<ul>
  <li>Proof of concept (P.O.C) - A targeted solution to a specific technical challenge that is needed to fulfill the scope
of a larger software product, but which does not necessarily fulfill the requirements of the software product 
as a whole. Proofs of concept are usually used to help nail down the feasibility of a solution or to improve time or
effort estimations.</li>
  <li>Prototype - A limited, non-production version of a software product intended to get feedback on the product approach, but 
not necessarily the technical approach. Prototypes are useful in getting quick feedback on a solution and iterating 
to a final design.</li>
  <li>Minimum Viable Product (M.V.P) - A production version of a software product which meets the minimum scope to 
provide customer value. M.V.Ps are meant to be iterated on, but must be fully functional.</li>
  <li>Technology Demonstration - A demonstration of a potential technology which is not targeted towards any particular
problem. Tech. Demos are meant to help learn a new technology and assess its usefulness for a software solution without
targeting a particular technical approach.</li>
</ul>

<p>These definitions are my own and may be used interchangeably elsewhere, but I like to use this taxonomy as it helps
to clarify the purpose of several pre-production versions of software.</p>

<h3 id="step-1-identify-required-scope">Step 1: Identify required scope</h3>

<p>Sometimes proofs of concept fail to be useful because the team or person making the P.O.C. doesn’t know what they are 
trying to solve. This happens when teams identify a technology they want to use but not what they actually want to do with it.
For example, a team might say “we want to containerize our application”, but doesn’t specify why they want to do that or what the 
containerization is meant to achieve. The person making the P.O.C. then makes a Dockerfile, runs a “hello world” application on it
then calls it a P.O.C. This is not a P.O.C. I would call this a technology demonstration: not useless if you have no experience 
with Docker, but it doesn’t really get you any closer to assessing the feasibility of your proposed solution to your problem.</p>

<p>In order to have a successful P.O.C. you must identify the required scope of the software product. Using a real example, my team 
wanted to replace our in-house OAuth2 identity provider with something else and we decided to assess a well regarded open source 
solution. We were looking for as close to a a drop-in replacement as we could, and, as such, it would need to do several things:</p>

<ol>
  <li>Support authorization code, client credentials, refresh token, and jwt-bearer grant types</li>
  <li>Support custom HTML/CSS on login page based on URL parameters</li>
  <li>Have default scopes that do not prompt users</li>
  <li>Limit scopes and grant types on a per-client basis</li>
  <li>Allow close to zero downtime migration of users with hashed/salted passwords</li>
  <li>Allow close to zero downtime migration of existing clients with custom fields</li>
  <li>Allow passing authentication for some users to a third-party OAuth provider</li>
  <li>Support client-only authentication with the jwt-bearer grant type</li>
  <li>Support the OIDC protocol</li>
  <li>Have support for RBAC</li>
  <li>Allow JWT claim customization</li>
</ol>

<p>This scope would be too much for a P.O.C. as anything that would fulfill all of it would basically be the final product.
To get the scope of the P.O.C. we needed to use our best judgement to identify the factors that presented the biggest technical 
challenges or which had the highest uncertainty. We knew that anything that supported OAuth2 and OIDC would support the most common
grant types: authorization code, client credentials and refresh token, but jwt-bearer was a bit rarer of a grant type, so that was 
what we focused on. We also knew from reading documentation that things like custom login pages, default scopes, RBAC support, and JWT claim customization should be possible. Based on this, we focused our P.O.C. on the following requirements:</p>

<ol>
  <li>Allow close to zero downtime migration of users with hashed/salted passwords</li>
  <li>Allow close to zero downtime migration of clients with custom fields</li>
  <li>Allow passing authentication for some users to third-party OAuth provider</li>
  <li>Support client-only authentication with jwt-bearer grant type</li>
</ol>

<h3 id="step-2-timebox-your-poc">Step 2: Timebox your P.O.C.</h3>

<p>One of the issues with proofs of concept is that, given enough time, nearly any approach is possible. To
really assess the feasibility of an approach you need to assess the ability to do it within a reasonable amount
of time. For that reason, set a time limit for your P.O.C., usually no more than two weeks. The goal is to
achieve as much as you can of your targeted scope in that time, and, even if you don’t end up finishing everything
you set out to, you should have a good idea of what is easy, what is possible, what is difficult, and what is impossible in that time.</p>

<p>For our OAuth2 project, we gave ourselves two weeks to build something that achieved the required scope. Doing so
required some hacks, but we did as much as we could. After two weeks we realized that using a third-party OAuth2 provider
would be easy, migrating users would be possible, supporting client-only authentication with jwt-bearer flow would be
difficult, and migrating existing clients with custom fields would be nearly impossible. 
This was a surprise as we expected client migration to be an out-of-the-box feature for an OAuth2 provider;
however, while it was possible to pass off client auth. to a custom service, there was no way of managing
our implementation of custom fields via readily accessible methods (we could have forked the code and used private methods, but
decided that was a bad idea).</p>

<h3 id="step-3-demo-and-record-your-findings">Step 3: Demo and record your findings</h3>

<p>The last step to a P.O.C. is to demo it to others and record what you figured out so that others can replicate it. For our OAuth2
project I made a presentation in which I demonstrated what we could build and also explained the challenges we faced. 
We ultimately decided not to go with the open source identify provider because it could not support the client only authentication
we used for our service accounts.</p>

<h3 id="what-makes-a-good-poc">What makes a good P.O.C.</h3>

<p>A good P.O.C. is targeted to the most uncertain or challenging technical aspects of an approach to a software problem and
assesses the feasibility of the approach without taking too long to implement. The most common reason, in my experience, that 
P.O.Cs fail to be useful is that they target the wrong thing: usually targeting the most important or common use case, but
not necessarily the most difficult or uncertain. Sometimes they aren’t even really P.O.C.s, but technology demonstrations.
I also see teams spend too much time on P.O.Cs, building out complete or polished pieces of
software as if they would end up in production. This is also a mistake as you lose some of the usefulness
of a P.O.C., which is that it is a quick way of assessing feasibility of an approach. If you actually implement the approach, you may as well have skipped the P.O.C. and just started building the real thing.</p>
</div>

    
    
        
    
        
    
        
    
        
            

    <div class="flex flex-row m-t-3">
        <div class="flex-item">
            
                
                
                <a href="/2024/02/27/are-houses-actually-more-expensive.html">Previous Post: Are Houses Actually Mo...</a>
            
        </div>
        <div class="flex-item flex-right">
            
            
        </div>

    </div>


</article>
      </div>
    </main>
  </body>

</html>
